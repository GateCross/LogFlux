name: build-and-push

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: build-and-push-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ${{ vars.REGISTRY || 'ghcr.io' }}
  IMAGE_NAME: ${{ vars.IMAGE_NAME || github.repository }}
  PLATFORM: ${{ vars.PLATFORM || 'linux/amd64,linux/arm64' }}
  CADDY_IMAGE: ${{ vars.CADDY_IMAGE || 'ghcr.io/gatecross/logflux-caddy:latest' }}

jobs:
  frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Set up pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9.15.4
          run_install: false

      - name: Get pnpm store path
        id: pnpm-store
        run: echo "STORE_PATH=$(pnpm store path)" >> "$GITHUB_OUTPUT"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: pnpm-${{ runner.os }}-${{ hashFiles('frontend/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: Install deps
        env:
          SKIP_SIMPLE_GIT_HOOKS: 1
        run: pnpm -C frontend install --frozen-lockfile

      - name: Build frontend
        run: pnpm -C frontend run build

      - name: Upload dist
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  backend:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: backend/go.mod
          cache: true
          cache-dependency-path: backend/go.sum

      - name: Download deps
        working-directory: backend
        run: go mod download

      - name: Build backend
        working-directory: backend
        env:
          CGO_ENABLED: 0
          GOOS: linux
          GOARCH: ${{ matrix.arch }}
        run: |
          mkdir -p ../build-artifacts/backend/${{ matrix.arch }}
          go build -a -installsuffix cgo -ldflags="-w -s" -o ../build-artifacts/backend/${{ matrix.arch }}/logflux-api .

      - name: Upload backend
        uses: actions/upload-artifact@v4
        with:
          name: backend-${{ matrix.arch }}
          path: build-artifacts/backend/${{ matrix.arch }}/logflux-api

  build:
    needs: [frontend, backend]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download frontend
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: build-artifacts/frontend/dist

      - name: Download backend (amd64)
        uses: actions/download-artifact@v4
        with:
          name: backend-amd64
          path: build-artifacts/backend/amd64

      - name: Download backend (arm64)
        uses: actions/download-artifact@v4
        with:
          name: backend-arm64
          path: build-artifacts/backend/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/runtime.Dockerfile
          platforms: ${{ env.PLATFORM }}
          push: true
          build-args: |
            CADDY_IMAGE=${{ env.CADDY_IMAGE }}
          provenance: false
          sbom: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  cleanup:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Cleanup old image versions
        uses: actions/github-script@v7
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        with:
          script: |
            const owner = context.repo.owner;
            const imageName = process.env.IMAGE_NAME || '';
            const packageName = (imageName.includes('/') ? imageName.split('/').slice(1).join('/') : imageName).toLowerCase();

            if (!packageName) {
              core.setFailed('PACKAGE_NAME is empty; cannot cleanup GHCR versions.');
              return;
            }

            async function listVersions(page) {
              try {
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  per_page: 100,
                  page
                });
              } catch (err) {
                if (err.status !== 404) throw err;
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                  username: owner,
                  package_type: 'container',
                  package_name: packageName,
                  per_page: 100,
                  page
                });
              }
            }

            async function deleteVersion(id, isOrg) {
              if (isOrg) {
                return await github.rest.packages.deletePackageVersionForOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  package_version_id: id
                });
              }
              return await github.rest.packages.deletePackageVersionForUser({
                username: owner,
                package_type: 'container',
                package_name: packageName,
                package_version_id: id
              });
            }

            let versions = [];
            let page = 1;
            let isOrg = true;

            while (true) {
              const res = await listVersions(page);
              versions = versions.concat(res.data);
              if (res.data.length < 100) break;
              page += 1;
            }

            if (versions.length <= 5) {
              core.info(`No cleanup needed. ${versions.length} version(s) found.`);
              return;
            }

            // Determine owner type for delete calls
            try {
              await github.rest.orgs.get({ org: owner });
              isOrg = true;
            } catch (err) {
              isOrg = false;
            }

            versions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const toDelete = versions.slice(5);

            for (const v of toDelete) {
              await deleteVersion(v.id, isOrg);
              core.info(`Deleted version id=${v.id}`);
            }
