name: build-caddy

on:
  push:
    branches:
      - main
    paths:
      - docker/Caddyfile
      - docker/caddy.Dockerfile
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: build-caddy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ${{ vars.REGISTRY || 'ghcr.io' }}
  IMAGE_NAME: ${{ vars.CADDY_IMAGE_NAME || 'gatecross/logflux-caddy' }}
  PLATFORM: ${{ vars.PLATFORM || 'linux/amd64,linux/arm64' }}

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/caddy.Dockerfile
          platforms: ${{ env.PLATFORM }}
          push: true
          provenance: false
          sbom: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  cleanup:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Cleanup old image versions
        uses: actions/github-script@v7
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        with:
          script: |
            const owner = context.repo.owner;
            const imageName = process.env.IMAGE_NAME || '';
            const packageName = (imageName.includes('/') ? imageName.split('/').slice(1).join('/') : imageName).toLowerCase();

            if (!packageName) {
              core.setFailed('PACKAGE_NAME is empty; cannot cleanup GHCR versions.');
              return;
            }

            async function listVersions(page) {
              try {
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  per_page: 100,
                  page
                });
              } catch (err) {
                if (err.status !== 404) throw err;
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                  username: owner,
                  package_type: 'container',
                  package_name: packageName,
                  per_page: 100,
                  page
                });
              }
            }

            async function deleteVersion(id, isOrg) {
              if (isOrg) {
                return await github.rest.packages.deletePackageVersionForOrg({
                  org: owner,
                  package_type: 'container',
                  package_name: packageName,
                  package_version_id: id
                });
              }
              return await github.rest.packages.deletePackageVersionForUser({
                username: owner,
                package_type: 'container',
                package_name: packageName,
                package_version_id: id
              });
            }

            let versions = [];
            let page = 1;
            let isOrg = true;

            while (true) {
              const res = await listVersions(page);
              versions = versions.concat(res.data);
              if (res.data.length < 100) break;
              page += 1;
            }

            if (versions.length <= 5) {
              core.info(`No cleanup needed. ${versions.length} version(s) found.`);
              return;
            }

            try {
              await github.rest.orgs.get({ org: owner });
              isOrg = true;
            } catch (err) {
              isOrg = false;
            }

            versions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const toDelete = versions.slice(5);

            for (const v of toDelete) {
              await deleteVersion(v.id, isOrg);
              core.info(`Deleted version id=${v.id}`);
            }